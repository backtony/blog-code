# docker란?

## 가상화란?
가상화란 __하나의 서버 자원을 나눠 가지며 성능을 분산시키고, 분산된 서버들이 각기 다른 서비스를 수행할 수 있게 하는 것__ 을 의미합니다.  
가상화를 통해 사용자가 많은 서비스에는 많은 자원을 할당해주고 적은 서비스에는 적게 할당할 수 있습니다.  

### 서버 가상화
![그림1](https://github.com/backtony/blog-code/blob/master/interview/docker/img/docker-1.PNG?raw=true)  
__서버 가상화란 하나의 물리적 서버 호스트에서 여러 개의 서버 운영 체제를 게스트로 실행할 수 있게 해주는 소프트웨어 아키텍처입니다.__  
이러한 서버 가상화를 구현해주는 기술은 __하이퍼바이저__ 입니다.  
하이퍼바이저는 __가상화 기술을 통해 여러 개의 운영체제를 하나의 호스트 OS에서 생성해서 사용할 수 있게 해주는 소프트웨어__ 입니다.  
이렇게 생성된 여러 개의 운영체제는 __가상머신__ 이라는 단위로 구별됩니다.  
각 가상머신에는 각각의 운영체제가 설치되어 사용됩니다.  
하이퍼바이저에 의해 생성되고 관리되는 운영 체제는 __게스트 운영체제__ 라 하며, 각 게스트 운영체제는 다른 게스트 운영체제와는 __완전히 독립된 공간과 시스템 자원을 할당__ 받아 사용합니다.  
하이퍼바이저의 역할을 정리해보면, 하이퍼바이저는 게스트 OS들에게 자원을 나눠주며 조율하고 OS들의 커널을 번역해서 하드웨어에게 전달합니다.  
대표적인 서버 가상화 툴로 VirtualBox, VMWare가 있습니다.  
__각종 시스템 자원을 가상화하고 독립된 공간을 생성하는 작업은 하이퍼바이저를 반드시 거치기 때문에 일반 호스트에 비해 성능 손실__ 이 발생합니다.  
또한 가상 머신에는 __게스트 운영체제를 사용하기 위한 라이브러리, 커널 등을 전부 포함__ 하기 때문에 배포하기 위한 이미지로 만들었을 때 크기 또한 커집니다.  
즉, 가상머신은 완벽한 운영체제를 생성할 수 있는 장점이 있지만, 성능이 느리고 용량상으로 부담이 있습니다.  

### 컨테이너 가상화
![그림2](https://github.com/backtony/blog-code/blob/master/interview/docker/img/docker-2.PNG?raw=true)  
이러한 문제를 해결하기 위해 컨테이너가 등장합니다.  
컨테이너는 __가상화된 공간을 생성하기 위해 리눅스 자체 기능__ 인 chroot, 네임스페이스, cgroup을 사용함으로써 __프로세스 단위의 격리 환경__ 을 만듭니다.  
그림에 보면 도커 엔진 위에 컨테이너가 할당된 것을 확인할 수 있습니다.  
컨테이너 안에는 애플리케이션을 구동하는데 필요한 라이브러리 및 실행 파일만 존재합니다.  
그렇기 때문에 이미지를 만들었을 때 이미지의 용량이 가상머신에 비해 대폭 줄어듭니다. 이에 따라 배포 시간도 줄고, 가상화된 공간을 사용했을 때 성능손실도 거의 없다는 장점이 있습니다.  


## 컨테이너란?
컨테이너란 __이미지(컨테이너를 만들기 위한 틀)의 목적에 따라 생성되는 프로세스를 격리된 환경에서 실행하는 기술__ 을 의미합니다.  
+ 컨테이너를 사용해야 하는 이유
    - Host와 격리된 환경을 보장하여 Host OS에 영향을 주지 않는다.
    - 가상머신과 달리 __커널을 공유하는 방식__ 으로 동작하여 성능상 손실이 적다.
    - 프로세스 관리 및 확장이 용이해진다.

## 도커란?
도커란 __컨테이너 기반 오픈소스 가상화 플랫폼__ 입니다.  
다음과 같은 일을 합니다.(이외에도 여러 가지 기능들을 합니다.)
+ 컨테이너의 라이프 사이클 관리
+ 컨테이너를 생성하기 위한 이미지 관리
+ 컨테이너의 데이터를 저장하기 위한 저상소 역할을 하는 볼륨 관리
+ 컨테이너의 접속을 관리하기 위한 네트워크 관리 

### 도커의 동작 흐름
![그림3](https://github.com/backtony/blog-code/blob/master/interview/docker/img/docker-3.PNG?raw=true)  
1. 사용자가 도커 명령어 입력한다.
2. 전달받은 도커 클라이언트는 /var/run/docker.sock에 위치한 유닉스 소켓을 통해 도커 데몬 API를 호출한다.
3. 도커 데몬(dockerd)은 명령어에 해당하는 작업을 수행하고 수행 결과를 도커 클라이언트에게 반환한다.
4. 사용자에게 결과가 출력된다. 

도커 데몬(dockerd)은 컨테이너를 생성하고 실행하며 이미지를 관리하는 역할을 합니다.  
도커 프로세스가 실행되어 입력을 받을 준비가 된 상태를 도커 데몬이라고 부르기도 합니다.

## 도커 스웜
![그림4](https://github.com/backtony/blog-code/blob/master/interview/docker/img/docker-4.PNG?raw=true)  
하나의 호스트에서 컨테이너가 많아져 CPU, 메모리 같은 자원이 부족해져서 새로운 컨테이너를 추가하지 못하는 상황이 발생한다고 가정해봅시다.  
<br><Br>

![그림5](https://github.com/backtony/blog-code/blob/master/interview/docker/img/docker-5.PNG?raw=true)  
가장 간단한 방법은 성능이 좋은 서버를 사면 됩니다.(Scale Up)  
하지만 Scale Up 방식으로 해결하게 되면 자원이 부족할 때마다 다시 사야하거나 기껏 자원을 사놨는데 그만큼이 자원의 필요하지 않을 수도 있다는 문제가 있습니다.  
<Br><br>

![그림6](https://github.com/backtony/blog-code/blob/master/interview/docker/img/docker-6.PNG?raw=true)  
따라서 가장 많이 사용하는 방법은 여러 대의 서버를 클러스터로 만들어 자원을 병렬로 확장하는 방식(Scale out)입니다.  
만약 놀고있는 자원이 많다면 다시 줄이면 됩니다.  
클러스터란 각기 다른 서버들을 하나로 묶어서 하나의 시스템 같이 동작하게 하는 것을 의미하는데 동일한 네트워크 풀을 쓰며 요청에 따라 트래픽을 분산할 수도 있게 됩니다.  
하지만 여러 대의 서버를 하나의 자원 풀로 만들고 어떠한 서버에 어떠한 컨테이너를 할당할 지에 대한 문제가 있는데 이러한 문제들을 해결하는 대표적인 오픈소스로 많은 솔루션들이 도커 스웜입니다.  
__도커 스웜은 마이크로 서비스 아키텍처의 컨테이너를 다루기 위한 클러스터링 기능에 초점을 맞춰 필요에 따라 유동적으로 컨테이너 수를 조절하고 컨테이너의 연결을 분산하는 로드밸런싱 기능을 자체적으로 지원__ 합니다.  
스웜모드는 도커 엔진 자체에 내장되어 있습니다.  
결론적으로 스웜모드는 서비스의 확장/관리를 편하게 하기 위해서 사용합니다.  

### 스웜 모드 구조
![그림7](https://github.com/backtony/blog-code/blob/master/interview/docker/img/docker-7.PNG?raw=true)  
스웜모드는 매니저 노드와 워커 노드로 구성되어 있습니다.  
+ 워커 노드
    - 실제 컨테이너가 생성되고 관리되는 도커 서버
+ 매니저 노드
    - 워커 노드를 관리하기 위한 도커 서버
    - 기본적으로 워커 노드의 역할도 한다.
    - 매니저 노드는 운영환경에서 다중화하여 매니저 노드의 부하를 분산하고, 특정 매니저 노드가 다운됬을 때 정상적으로 스웜 클러스터를 유지할 수 있도록 해야한다.

### 제어 단위 - 서비스
![그림8](https://github.com/backtony/blog-code/blob/master/interview/docker/img/docker-8.PNG?raw=true)  
일반적인 도커 명령어의 제어 단위는 컨테이너입니다.  
하지만 도커 스웜에서의 제어 단위는 __서비스__ 입니다.  
서비스는 __같은 이미지에서 생성된 컨테이너의 집합__ 을 의미합니다.  
서비스를 제어하면 해당 서비스 내의 컨테이너에 같은 명령이 수행 됩니다.  
이때 서비스 내의 컨테이너를 Task라고 부릅니다.  
<br><Br>

![그림9](https://github.com/backtony/blog-code/blob/master/interview/docker/img/docker-9.PNG?raw=true)  
위 그림은 Spring, nginx 2개의 서비스를 정의했습니다.  
서비스 내에 spring은 테스트 수를 3개, nginx는 2개로 설정했다면 위 그림과 같이 클러스터 안에는 spring 3개, nginx 2개가 있는 것을 확인할 수 있습니다.  
만약 노드에 장애가 발생하면 스웜은 서비스의 테스크들에 대한 상태를 계속 확인하다가 서비스 내에 정의된 레플리카 수만큼 존재하지 않으면 새로운 테스크 레플리카를 생성합니다.  
하지만 매니저 노드가 다운되면 클러스터는 사라지게 됩니다.  
이외에도 클러스터, 서비스, 네트워크, 노드 관리 등을 제공합니다.  

## 도커 컴포즈
바로 앞선 예시에서 spring과 nginx를 띄우려면 2번의 명령어를 입력해야 합니다.  
매번 명령어를 통해 서비스에 필요한 컨테이너를 생성할 수 있지만 이는 매우 비효율적입니다.  
이에 대한 해답으로 도커 컴포즈가 나오게 되었습니다.  
도커 컴포즈는 __여러 개의 컨테이너를 하나의 서비스로 정의하고 실행__ 합니다.  
도커 컴포즈는 도커 엔진에 내장되어 있지 않기 때문에 따로 설치애햐합니다.  
결론적으로 도커 컴포즈는 컨테이너의 생성을 편리하게 하기 위해 사용합니다.

### 실행 과정
![그림10](https://github.com/backtony/blog-code/blob/master/interview/docker/img/docker-10.PNG?raw=true)  
도커 컴포즈는 컨테이너의 설정이 정의된 yml 파일을 읽어 도커 엔진을 통해 컨테이너를 생성합니다.  







<Br><Br>

__참고__  
<a href="https://www.youtube.com/watch?v=IiNI6XAYtrs" target="_blank"> [10분 테코톡] ☂️ 검프의 Docker</a>  







